/**
 * GitHub Service
 * Handles git operations and GitHub PR creation for pushing generated tests
 */

import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export interface PushAndCreatePROptions {
  /** Absolute path to the generated test suite (e.g. swagger-tests/fakestoreapi) */
  suitePath: string;
  /** GitHub repo full name (e.g. "user/repo") */
  repoFullName: string;
  /** Branch name for the PR */
  branchName: string;
  /** Commit message */
  commitMessage: string;
  /** Base branch to open PR against (default: main) */
  baseBranch?: string;
  /** GitHub personal access token */
  githubToken: string;
}

export interface PushResult {
  success: boolean;
  prUrl?: string;
  branchName: string;
  error?: string;
}

export class GitHubService {
  /**
   * Push generated test files to a GitHub repo and create a PR.
   *
   * Strategy:
   * - Initialize a temp git repo at `repoRoot` (parent of suitePath)
   * - The spec folder (e.g. fakestoreapi/) becomes a subfolder in the target repo
   * - Write a .gitignore to exclude build artifacts
   * - Create a PR via GitHub REST API
   */
  async pushAndCreatePR(options: PushAndCreatePROptions): Promise<PushResult> {
    const {
      suitePath,
      repoFullName,
      branchName,
      commitMessage,
      baseBranch = 'main',
      githubToken,
    } = options;

    const repoRoot = path.dirname(suitePath);
    const specFolder = path.basename(suitePath);

    try {
      // 1. Init fresh git repo
      await this.execGit('init', repoRoot);
      await this.execGit(`config user.email "swagger-ai-agent@automated.dev"`, repoRoot);
      await this.execGit(`config user.name "Swagger AI Agent"`, repoRoot);

      // 2. Add the target remote
      const remoteUrl = `https://${githubToken}@github.com/${repoFullName}.git`;
      try {
        await this.execGit(`remote add target "${remoteUrl}"`, repoRoot);
      } catch {
        await this.execGit(`remote set-url target "${remoteUrl}"`, repoRoot);
      }

      // 3. Write .gitignore BEFORE staging
      const gitignoreContent = [
        '# Build artifacts',
        '**/target/',
        '**/build/',
        '',
        '# Allure tooling & reports',
        '**/.allure/',
        '**/allure-report/',
        '**/allure-results/',
        '',
        '# IDE',
        '**/.idea/',
        '**/.vscode/',
        '**/*.iml',
        '',
        '# OS',
        '.DS_Store',
        'Thumbs.db',
        '',
        '# Maven wrapper',
        '**/mvnw',
        '**/mvnw.cmd',
        '**/.mvn/',
        '',
        '# Compiled',
        '**/*.class',
        '**/*.jar',
        '**/*.war',
      ].join('\n');
      fs.writeFileSync(path.join(repoRoot, '.gitignore'), gitignoreContent, 'utf-8');

      // 4. Generate README for the spec folder
      const readmePath = path.join(suitePath, 'README.md');
      if (!fs.existsSync(readmePath)) {
        const readme = [
          `# ${specFolder} — AI-Generated REST Assured Tests`,
          '',
          'Auto-generated by **Swagger AI Agent**.',
          '',
          '## Prerequisites',
          '- Java 11+',
          '- Maven 3.6+',
          '',
          '## Run Tests',
          '```bash',
          'mvn test',
          '```',
          '',
          '## Allure Report',
          '```bash',
          'mvn allure:report',
          'open target/site/allure-maven-plugin/index.html',
          '```',
        ].join('\n');
        fs.writeFileSync(readmePath, readme, 'utf-8');
      }

      // 5. Stage all files first (respects .gitignore)
      await this.execGit(`add .gitignore`, repoRoot);
      await this.execGit(`add "${specFolder}"`, repoRoot);

      // 6. Create a tree object from the index (staged files)
      const tree = await this.execGit('write-tree', repoRoot);

      // 7. Fetch the base branch to get its history
      let parentArg = '';
      try {
        await this.execGit(
          `fetch target +refs/heads/${baseBranch}:refs/remotes/target/${baseBranch}`,
          repoRoot
        );
        const parentSha = await this.execGit(`rev-parse target/${baseBranch}`, repoRoot);
        parentArg = `-p ${parentSha}`;
      } catch {
        // Empty remote repo or no base branch — commit with no parent
      }

      // 8. Create a commit object with the tree and the correct parent
      //    This ensures our branch shares history with the base branch
      const commitSha = await this.execGit(
        `commit-tree ${tree} ${parentArg} -m "${commitMessage.replace(/"/g, '\\"')}"`,
        repoRoot
      );

      // 9. Point the branch at our new commit and checkout
      await this.execGit(`branch -f ${branchName} ${commitSha}`, repoRoot);
      await this.execGit(`checkout ${branchName}`, repoRoot);

      // 10. Push
      await this.execGit(`push -u target ${branchName} --force`, repoRoot);

      // 11. Create PR via GitHub API
      let prUrl: string | undefined;
      try {
        prUrl = await this.createPR({
          repoFullName,
          branchName,
          baseBranch,
          title: commitMessage,
          body: `## AI-Generated REST Assured Tests\n\nAutomatically generated by Swagger AI Agent.\n\n### Test Suite: ${specFolder}`,
          githubToken,
        });
      } catch (prError: any) {
        console.warn('PR creation note:', prError.message);
      }

      // 12. Cleanup: remove .git and .gitignore from repoRoot
      try {
        await execAsync(`rm -rf .git`, { cwd: repoRoot });
        fs.unlinkSync(path.join(repoRoot, '.gitignore'));
      } catch { /* best effort */ }

      return {
        success: true,
        prUrl,
        branchName,
      };
    } catch (error: any) {
      // Cleanup on error
      try {
        await execAsync(`rm -rf .git`, { cwd: repoRoot });
        const gi = path.join(repoRoot, '.gitignore');
        if (fs.existsSync(gi)) fs.unlinkSync(gi);
      } catch { /* ignore */ }

      return {
        success: false,
        branchName,
        error: error.message || String(error),
      };
    }
  }

  private async execGit(args: string, cwd: string): Promise<string> {
    const { stdout } = await execAsync(`git ${args}`, { cwd, timeout: 30_000 });
    return stdout.trim();
  }

  private async createPR(opts: {
    repoFullName: string;
    branchName: string;
    baseBranch: string;
    title: string;
    body: string;
    githubToken: string;
  }): Promise<string> {
    const { repoFullName, branchName, baseBranch, title, body, githubToken } = opts;
    const url = `https://api.github.com/repos/${repoFullName}/pulls`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${githubToken}`,
        Accept: 'application/vnd.github+json',
        'Content-Type': 'application/json',
        'X-GitHub-Api-Version': '2022-11-28',
      },
      body: JSON.stringify({
        title,
        body,
        head: branchName,
        base: baseBranch,
      }),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`GitHub API ${response.status}: ${text}`);
    }

    const data = await response.json() as { html_url: string };
    return data.html_url;
  }
}
